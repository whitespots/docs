# Архитектурные требования

### V1.1 Требования к процессу безопасной разработки \(SSDLC\)

1. Принципы SSDLC используется на всех этапах разработки. 
2. Производится моделирование угроз для каждого изменения в дизайне приложения или в спринтах планируется поиск угроз, планируются контрмеры и проводится тестирование на безопасность. 
3. Все пользовательские функции имеют ограничения безопасности, например "Я, как пользователь, могу просматривать и редактировать свой профиль. Я не должен видеть и редактировать чей-либо еще профиль"
4. Все точки доступа и доверия приложения, компонентов и значительных потоков данных документированы и их использование обосновано. 
5. Проведено определение и анализ высокоуровневой архитектуры приложения и всех подключенных удаленных сервисов. 
6. Внедрен централизованный, простой, проверенный, безопасный процесс контроля безопасности, чтобы избежать дублирования, отсутствия, неэффективного или небезопасного контроля. 
7. Всем разработчикам и тестировщикам доступны чек-листы, требования безопасности, инструкции или политики безопасности. 

### V1.2 Аутентификация

1. Во всех приложениях, компонентах, сервисах и на всех серверах используются уникальные или специальных низко привилегированные учетные записи операционной системы
2. Используется аутентификация в коммуникациях между компонентами приложений, включая API, промежуточное ПО и уровни данных. Компоненты должны иметь привилегии не выше необходимого минимума. 
3. Приложение использует единый проверенный и безопасный механизм аутентификации, он может быть расширен для использования строгой аутентификации, имеет подробное логирование для обнаружения зловредных действий с аккаунтов. 
4. Все пути аутентификации и API контроля идентификации производят последовательный контроль безопасности аутентификации и нет иных небезопасных альтернатив для аутентификации. 

### V1.4 Управление доступом

1. Все точки управления доступом, такие как шлюзы управления доступом, серверы, бессерверные функции обеспечивают контроль доступа. Управление доступом не производится на стороне клиента. 
2. Выбранное решение для управления доступом достаточно гибкое, чтобы обеспечить нужды приложения. 
3. Для всех функций, данных, URL адресов, контроллеров, сервисов и других ресурсов применяется принцип минимально необходимых привилегий. 
4. Приложение использует единственный и хорошо проверенный механизм контроля доступа для обращения к защищенным данным и ресурсам. Все запросы должны передаваться через этот единый механизм. 
5. Контроль доступа использует атрибут или функцию, которая проверяет, есть ли у данного авторизованного пользователя доступ к функции / данным, а не просто проверяет его роль. Разрешения все же должны выдаваться на основе ролей. 

### V1.5 Ввод и вывод

1. Требования к вводу и выводу четко определяют как обрабатывать данные на основе типа, контента, применяемых законов, нормативов и других политик.  
2. Сериализация не используется в коммуникации с недоверенными клиентами. Если это невозможно, то для предотвращения атак десериализации и инъекции объектов применяются средства контроля целостности \(и шифрование, если отправляются конфиденциальные данные\). 
3. Проверка ввода используется на доверенном сервисном уровне. 
4. Кодировка вывода происходит рядом с интерпретатором, для которого она предназначена, или с помощью этого интерпретатора. 

### V1.6 Криптография

1. Существует четкая политика управления криптографическими ключами и жизненный цикл криптографического ключа соответствует стандарту управления ключами, например [NIST SP 800-57](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r4.pdf).
2. Пользователи криптографических сервисов защищают конфиденциальные данные и другие секреты с помощью хранилищ ключей или альтернатив на основе API.
3. Все ключи и пароли заменяемы, работают через четко определенный процесс для возможности повторного шифрования конфиденциальных данных при смене ключа / пароля.
4. Все ключи, пароли или секреты API, сгенерированные при помощи симметричных алгоритмов, генерируемые клиентами или предоставляемые им, используются только для защиты секретов с низким уровнем риска, например, при шифровании локального хранилища, для временного использования, как, например, обфускация параметров. Обмен секретами с клиентами производится эквивалентно чистому тексту с архитектурной точки зрения. 

### V1.7 Ошибки, логирование и аудит

1. В системе используется общий формат и подход к логированию.
2. Логи безопасно передаются в, предпочтительно, удаленную систему для анализа, обнаружения, оповещения и эскалации. 

### V1.8 Приватность и защита данных

1. Все конфиденциальные данные идентифицированы и классифицированы по уровням защиты. 
2. Все уровни защиты имеют взаимосвязанные требования защиты, например, требования шифрования, целостности, приватности и иных требований конфиденциальности и эти требования применены в архитектуре. 

### V1.9 Коммуникации

1. Приложение шифрует коммуникации между компонентами, в частности, когда эти компоненты находятся в разных контейнерах, системах, сайтах или в разных облачных сервисах. 
2. Компоненты приложения проверяют подлинность каждой стороны коммуникации, чтобы предотвратить man-in-the-middle атаку. Например, компоненты приложения должны валидировать TLS сертификаты и цепочки доверия. 

### V1.10 Вредоносное ПО

1. Используется система контроля исходного кода, в ней можно создать тикеты о проблемах и изменениях. В этой системе используется контроль доступа и отслеживаются любые изменения идентифицированных пользователей. 

### V1.11 Бизнес логика

1. Определены и описаны все бизнес функции и функции безопасности компонентов приложения. 
2. Все бизнес процессы, включая аутентификацию, управление сессиями и контроль доступа, едины и не имеют дублирования. 
3. Все бизнес процессы, включая аутентификацию, управление сессиями, управление доступом устойчивы к атакам "time-of-check" и "time-of-use race conditions"

### V1.12 Безопасная загрузка файлов

1. Загружаемые пользователями файлы хранятся вне директории веб-приложения. 
2. Загруженные пользователями файлы, если требуется их отображение или загрузка через приложение, обрабатываются через MIME-тип `application/octet-stream` или через внешний домен, как, например, облачное хранилище. Реализована подходящая политика безопасности контента, чтобы снизить риск от XSS-векторов или других атак со стороны загруженного файла.

### V1.14 Конфигурация

1. Компоненты разделены на разные уровни доверия через четко определенную схему контроля безопасности, правила брандмауэра, API-шлюзы, обратные прокси, облачные группы безопасности или похожие механизмы. 
2. При развертывании исполняемых файлов на недоверенных устройствах используются подписи, доверенные соединения и проверенные конечные точки. 
3. Пайплайны предупреждают об устаревших и небезопасных компонентах при сборке и при необходимости прерывают сборку. 
4. Пайплайн содержит этап сборки для автоматической сборки и подтверждения безопасного развертывания приложения, особенно если инфраструктура приложения определяется кодом \(Software-defined infrastructure или SDI\), например, скрипты сборки облачного окружения.
5. Развертывание приложения изолировано, контейнеризовано на сетевом уровне, чтобы осложнить и задержать атаку из других приложений, особенно, если атакующие производят десериализацию.
6. Приложение не использует неподдерживаемые, небезопасные или устаревшие технологии на стороне клиента, например плагины NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL, или Java апплеты на стороне клиента.

