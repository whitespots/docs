# ASVS V4 SDLC Split \(rus\)

**Low - First steps, automated, or whole of portfolio view** 

An application achieves ASVS Level 1 if it adequately defends against application security vulnerabilities that are easy to discover, and included in the OWASP Top 10 and other similar checklists. Level 1 is the bare minimum that all applications should strive for. It is also useful as a first step in a multi-phase effort or when applications do not store or handle sensitive data and therefore do not need the more rigorous controls of Level 2 or 3. Level 1 controls can be checked either automatically by tools or simply manually without access to source code. We consider Level 1 the minimum required for all applications. Threats to the application will most likely be from attackers who are using simple and low effort techniques to identify easy-to-find and easy-to-exploit vulnerabilities. This is in contrast to a determined attacker who will spend focused energy to specifically target the application. If data processed by your application has high value, you would rarely want to stop at a Level 1 review.

**Medium - Most applications** 

An application achieves ASVS Level 2 \(or Standard\) if it adequately defends against most of the risks associated with software today. Level 2 ensures that security controls are in place, effective, and used within the application. Level 2 is typically appropriate for applications that handle significant business-to-business transactions, including those that process healthcare information, implement business-critical or sensitive functions, or process other sensitive assets, or industries where integrity is a critical facet to protect their business, such as the game industry to thwart cheaters and game hacks. OWASP Application Security Verification Standard 4.0 11 Threats to Level 2 applications will typically be skilled and motivated attackers focusing on specific targets using tools and techniques that are highly practiced and effective at discovering and exploiting weaknesses within applications.

**High - High value, high assurance, or high safety** 

ASVS Level 3 is the highest level of verification within the ASVS. This level is typically reserved for applications that require significant levels of security verification, such as those that may be found within areas of military, health and safety, critical infrastructure, etc. Organizations may require ASVS Level 3 for applications that perform critical functions, where failure could significantly impact the organization's operations, and even its survivability. Example guidance on the application of ASVS Level 3 is provided below. An application achieves ASVS Level 3 \(or Advanced\) if it adequately defends against advanced application security vulnerabilities and also demonstrates principles of good security design. An application at ASVS Level 3 requires more in depth analysis or architecture, coding, and testing than all the other levels. A secure application is modularized in a meaningful way \(to facilitate resiliency, scalability, and most of all, layers of security\), and each module \(separated by network connection and/or physical instance\) takes care of its own security responsibilities \(defense in depth\), that need to be properly documented. Responsibilities include controls for ensuring confidentiality \(e.g. encryption\), integrity \(e.g. transactions, input validation\), availability \(e.g. handling load gracefully\), authentication \(including between systems\), non-repudiation, authorization, and auditing \(logging\).

## Governance 

### V1.1 Требования к процессу безопасной разработки \(SSDLC\)

**Средние и высокие требования:**

1. Принципы SSDLC используется на всех этапах разработки. 
2. Моделируются угрозы для каждого изменения в дизайне приложения или в спринтах планируется поиск угроз, планируются контрмеры и проводится тестирование на безопасность. 
3. Все пользовательские функции имеют ограничения безопасности, например "Я, как пользователь, могу просматривать и редактировать свой профиль. Я не должен видеть и редактировать чей-либо еще профиль"
4. Все точки доступа и доверия приложения, компонентов и значительных потоков данных документированы и их использование обосновано. 
5. Проведено определение и анализ высокоуровневой архитектуры приложения и всех подключенных удаленных сервисов. 
6. Внедрена централизованная, простая, проверенная, безопасная система контроля безопасности, чтобы избежать дублирования, отсутствия, неэффективного или небезопасного контроля. 
7. Всем разработчикам и тестировщикам доступны чек-листы, требования безопасности, инструкции или политики безопасности. 

## Design \(architecture\)

Listed here are key requirements. Check the Verification domain below and make sure these requirements are met.  

### V1.7 Ошибки, логирование и аудит

**Средние и высокие требования:**

1. В системе используется общий формат и подход к логированию.
2. Логи безопасно передаются в, предпочтительно, удаленную систему для анализа, обнаружения, оповещения и эскалации. 

### V1.8 Приватность и защита данных

**Средние и высокие требования:**

1. Все конфиденциальные данные идентифицированы и классифицированы по уровням защиты. 
2. Все уровни защиты имеют взаимосвязанные требования защиты, например, требования шифрования, целостности, сохранения, приватности и иных требований конфиденциальности и приватности и эти требования применены в архитектуре. 

### V1.9 Коммуникации

**Средние и высокие требования:**

1. Приложение шифрует коммуникации между компонентами, в частности, когда эти компоненты находятся в разных контейнерах, системах, сайтах или в разных облачных сервисах. 
2. Компоненты приложения проверяют подлинность каждой стороны коммуникации, чтобы предотвратить men-in-the-middle атаку. Например, компоненты приложения должны валидировать TLS сертификаты и цепочки доверия. 

### V1.10 Вредоносное ПО

**Средние и высокие требования:**

1. Используется система контроля исходного кода, в ней можно создать тикеты о проблемах и изменениях. В этой системе используется контроль доступа и отслеживаются любые изменения идентифицированных пользователей. 

### V1.11 Бизнес логика 

**Средние требования:** 

1. Определены и описаны все бизнес функции и функции безопасности компонентов приложения. 
2. Синхронизирвоаны все ценные бизнес процессы, включая аутентификацию, управление сессиями и контроль доступа. 

**Только высокие требования:** 

1. Все бизнес процессы, включая аутентификацию, управление сессиями, управление доступом устойчивы к атакам "time-of-check" и "time-of-use race conditions"

### \*V1.2 Аутентификация

**Средние и высокие требования:**

1. Во всех приложениях, компонентах, сервисах и на всех серверах используются уникальные или специальных низкопривилегированные учетные записи операционной системы
2. Используется аутентификация в коммуникациях между компонентами приложений, включая API, промежуточное ПО и уровни данных. Компоненты должны иметь привилегии не выше необходимого минимума. 
3. \*Приложение использует единый проверенный и безопасный механизм аутентификации, он может быть расширен для использования строгой аутентификации, имеет подробное логирование для обнаружения зловредных действий с аккаунтов. 
4. \*Все пути аутентификации и API контроля идентификации производят последовательный контроль безопасности аутентификации и нет иных небезопасных альтернатив для аутентификации. 

### V1.4 Управление доступом

**Средние и высокие требования:**

1. Все точки управления доступом, такие как шлюзы управления доступом, серверы, бессерверные функции обеспечивают контроль доступа. Управление доступом не производится на стороне клиента. 
2. Выбранное решение для управления доступом достаточно гибкое, чтобы обеспечить нужды приложения. 
3. Для всех функций, данных, URL адресов, контроллеров, сервисов и других ресурсов применяется принцип минимально необходимых привилегий. 
4. Приложение использует единственный и хорошо проверенный механизм контроля доступа для обращения к защищенным данным и ресурсам. Все запросы должны передаваться через этот единый механизм. 
5. Контроль доступа использует атрибут или функцию, которая проверяет, есть ли у данного авторизованного пользователя доступ к функции / данным, а не просто проверяет его роль. Разрешения все же должны выдаваться на основе ролей. 

### V1.5 Ввод и вывод

**Средние и высокие требования:**

1. Требования к вводу и выводу четко определяют как обрабатывать данные на основе типа, контента, применяемых законов, нормативов и других политик.  
2. Сериализация не используется в коммуникации с недоверенными клиентами. Если это невозможно, то для предотвращения атак десериализации и инъекции объектов применяются средства контроля целостности \(и шифрование, если отправляются конфиденциальные данные\). 
3. Проверка ввода используется на доверенном сервисном уровне. 
4. Убедитесь, что кодировка вывода происходит рядом с интерпретатором, для которого она предназначена, или с помощью этого интерпретатора. 

### V1.6 Криптография

**Средние и высокие требования:**

1. Существует четкая политика управления криптографическими ключами и жизненный цикл криптографического ключа соответствует стандарту управления ключами, например NIST SP 800-57.
2. Пользователи криптографических сервисов защищают конфиденциальные данные и другие секреты с помощью хранилищ ключей или альтернатив на основе API.
3. Все ключи и пароли заменяемы, работают через четко определенный процесс для возможности повторного шифрования конфиденциальных данных при смене ключа / пароля.
4. Все ключи, пароли или секреты API, сгенерированные при помощи симметричных алгоритмов, генерируемые клиентами или предоставляемые им, используются только для защиты секретов с низким уровнем риска, например, при шифровании локального хранилища, для временного использования, как, например, обфусация параметров. Обмен секретами с клиентами производится эквивалентно чистому тексту с архитектурной точки зрения. 

### V1.12 Безопасная загрузка файлов

**Средние и высокие требования:**

1. Загружаемые пользователями файлы хранятся вне директории веб-приложения. 
2. Загруженные пользователями файлы, если требуется их отображение или загрузка через приложение, обрабатываются через MIME-тип `application/octet-stream` или через внешний домен, как, например, облачное хранилище. Реализована подходящая политика безопасности контента, чтобы снизить риск от XSS-векторов или других атак со стороны загруженного файла.

### V1.14 Конфигурация

**Средние и высокие требования:**

1. Компоненты разделены на разные уровни доверия через четко определенную схему контроля безопасности, правила брандмауэра, API-шлюзы, обратные прокси, облачные группы безопасности или похожие механизмы. 
2. При развертывании исполняемых файлов на недоверенных устройствах используются подписи, доверенные соединения и проверенные конечные точки. 
3. Пайплайны предупреждают об устаревших и небезопасных компонентах при сборке и при необходимости прерывают сборку. 
4. Пайплайн содержит этап сборки для автоматической сборки и подтверждения безопасного развертывания приложения, особенно если инфраструктура приложения определяется кодом \(Software-defined infrastructure или SDI\), например, скрипты сборки облачного окружения.
5. Развертывание приложения изолировано, контейнеризовано на сетевом уровне, чтобы осложнить и задержать атаку из других приложений, особенно, если атакующие производят десериализацию.
6. Приложение не использует неподдерживаемые, небезопасные или устаревшие технологии на стороне клиента, например плагины NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL, или Java апплеты на стороне клиента.

### V2.2 Общие требования к аутентификатору

**Низкие, средние и высокие требования:**

1. Уведомления безопасности отправляются пользователям после обновлений в части аутентификации, например, при смене учетных данных, вход из неизвестных или опасных локаций. Предпочтительно использование PUSH-уведомлений вместо SMS или уведомлений по электронной почте, а в случае отсутствия возможности отправлять PUSH-уведомления, SMS или email-уведомления не должны содержать конфиденциальной информации. 

**Только высокие требования::** 

1. Используется защита от выдачи атакующего за клиента вследствие фишинг атак, например, через многофакторную аутентификацию, использование крипторафических устройств с подтверждением \(например, привязанные ключи, требующие нажатия для аутентификации\) или через аутентификацию на высших уровнях ALL \(Authenticator Assurance Level\), сертификаты на стороне клиента. 
2. Поставщик учетных данных \(credential service provider или CSP\) и приложение, проверяющее подлинность аутентификации, разделены и между ними находится аутентифицированный обеими сторонами TLS. 
3. Реализована защита от атаки повторного воспроизведения через использование OTP-устройств, криптографических аутентификаторов или кодов подтверждения. 
4. При попытке аутентификации, приложение требует ввода OTP-токена или действия, заданного пользователем, например, нажатия кнопки на ключе FIDO. 

### V2.3 Жизненный цикл аутентификатора

**Низкие, средние и высокие требования:** 

1. Сгенерированные системой начальные пароли или коды активации создаются с помощью генератора случайных чисел, должны содержать не менее 6 символов, могут содержать буквы и цифры, истекать через короткий период времени. Эти начальные секреты не используются в долгосрочной перспективе. 

**Только средние и высокие требования:**

1. Поддерживается регистрация и использование выбранных пользователями устройств аутентификации, как, например токены U2F или FIDO. 
2. При приближении окончания срока действия аутентификатора, инструкции по обновлению отправляются пользователю с учетом достаточного времени для прохождения процедуры обновления. 

### \*V2.4 Хранение учетных данных 

**Средние и высокие требования:**

1. \*Пароли хранятся в форме, устойчивой к офлайн атакам. Пароли должны быть хешированы с добавлением "соли" с использованием утвержденной функции шифрования ключа или функции хеширования пароля. Эти функции берут пароль, соль и фактор стоимости на вход, когда генерируют хэш пароля. 
2. Соль содержит в себе не менее 32 битов и была создана рандомно для минимизации возможности повторного использования этой соли среди хранимых хешей. Для каждого набора учетных данных хранится уникальное значение соли и сгенерированный хэш. 
3. Если используется PBKDF2, количество итераций должно быть велико настолько, насколько позволяет производительность верификационного сервера, что часто составляет 100 000 итераций. 
4. Если используется bcrypt, фактор работы должен быть высоким настолько, насколько это позволяет производительность сервера, что часто составляет минимум 13 единиц. 
5. Используется дополнительная итерация функции формирования ключа, где значение соли хранится в секрете и доступно только верификатору. Значение соли генерируется с использованием генератора рандомного бита \[SP 800-90Ar1\], при этом защищенность должна соответствовать последней версии стандарта SP 800-131A. Секретное значение соли должно храниться отдельно от хешированных паролей \(на специальном устройстве, например, на криптографическом ключе\)

### V4.1 Управление доступом

**Низкие, средние и высокие требования:** 

1. Приложение применяет правила контроля доступа на доверенном сервисном уровне, особенно если контроль доступа присутствует на стороне клиента. 
2. Все атрибуты пользователей и данных, а также информация о политике, используемая в контроле доступа, не могут меняться конечными пользователями кроме случаев, когда пользователи авторизованы для таких изменений.
3. Для защиты от подмены и повышения привилегий, существует принцип наименьших привилегий - пользователи должны иметь доступ только к определенным функциям, файлам, URL, контроллерам, службам и другим ресурсам.
4. Существует принцип запрета по умолчанию, в соответствии с которым новые пользователи/роли начинают с минимальными разрешениями или вообще без них, а старые пользователи/роли не получают доступ к новым функциям до тех пор, пока доступ не будет явно назначен.
5. Контроль доступа отключается \(в том числе аварийно\) безопасно, в том числе при возникновении исключений.

### V4.2 Управление доступом на уровне ОС

**Низкие, средние и высокие требования:** 

1. Конфиденциальные данные и API защищены от прямых атак на объекты, направленных на создание, чтение, обновление и удаление записей, например, создание или обновление чьей-либо записи, просмотр всех записей или удаление всех записей.
2. Приложение или фреймворк использует  анти-CSRF механизм для защиты аутентифицированной функциональности, а анти-автоматизация или анти-CSRF защищает неаутентифицированную функциональность.

### V4.3 Прочие соображения о контроле доступа

**Низкие, средние и высокие требования:** 

1. Административные интерфейсы используют соответствующую многофакторную аутентификацию для предотвращения несанкционированного использования.
2. Просмотр каталогов отключен, если только это не требуется. Приложения не раскрывают метаданные файлов или каталогов, например, скрыты файлы с расширениями Thumbs.db, .DS\_Store, .git или .svn.

**Только средние и высокие требования:** 

1. Для избежания мошеннических действий, приложение имеет дополнительную авторизацию \(например, с постепенным повышением привилегий или адаптивную аутентификацию\) для систем с более низкой стоимостью и / или разделение обязанностей для приложений с высокой стоимостью.

### V5.2 Песочника и санитизация

**Низкие, средние и высокие требования:** 

1. Весь недоверенный HTML ввод от редакторов WYSIWYG или аналогичных санитизирован с помощью библиотеки санитизации HTML или с помощью функционала фреймворка. 
2. Неструктурированные данные санитизируются, чтобы предотвратить использование опасных последовательностей символов и превышение длинны строки. 
3. Приложение санитизирует ввод пользователя, прежде чем направлять его в почтовые сервисы, чтобы избежать  SMTP или IMAP инъекций.
4. Приложение не использует функцию  eval\(\) или других функций динамического исполнения кода. Если нет альтернативы, любой ввод пользователя должен быть санитизирован или помещен в песочницу, прежде чем исполняться.
5. Приложение защищено от атаки внедрения шаблона, санитизируя или отправляя в песочницу любой ввод пользователя.
6. Приложение защищено от SSRF атак валидируя и санитизируя недоверенные данные или метаданные, используется белый список протоколов, доменов, путей и портов. 
7. Приложение санитизирует, отключает или отправляет в песочницу отправляемый пользователем контент, содержащий SVG скрипты, так как они могут содержать XSS или foreignObject. 
8. Приложение санитизирует, отключает или отправляет в песочницу отправленный пользователем контент, написанный на скриптовых языках, например Markdown, CSS или XSL stylesheets, BBCode и прочие.

### V5.3 Кодирование вывода и предотвращение инъекций

**Низкие, средние и высокие требования:** 

1. Кодирование на вывод соответствует интерпретатору и контексту. Например, используются отдельные кодировщики для значений, атрибутов HTML, для JavaScript, параметров, заголовков URL, SMTP и других интерпретаторов, в зависимости от контекста, особенно для недоверенного ввода \(имена с символами юникода или с апострофами, например ねこ или O'Hara\).
2. Кодирование на вывод обрабатывает набор символов и локаль, выбранные пользователем \(каждый символ юникода валиден и безопасно обрабатывается\).
3. Производится, в зависимости от контекста, автоматическое или, в худшем случае, ручное экранирование для защиты от XSS атак \(например, reflected, stored и DOM\)
4. Выбор данных или запросы к базам данных \(SQL, HQL, ORM, NoSQL\) используют параметризированные запросы, ORM, фреймворки ввода или как-либо иначе защищены от инъекций в БД. 
5. В случаях, когда не используется параметризация или иных безопасных механизмов нет, используется кодирование вывода \(в зависимости от контекста\) для защиты от инъекций, например, используется SQL экранирование, чтобы предотвратить SQL инъекции. 
6. Приложение защищено от JavaScript или JSON инъекций, включая атаки eval\( \), внедрение JavaScript, обход CSP, DOM XSS.
7. Приложение защищено от LDAP инъекций или были предприняты меры по предотвращению таких инъекций. 
8. Приложение защищено от инъекций команд в ОС и вызовы ОС производятся при помощи параметризированных запросов. 
9. Приложение щашишено от атак LFI и RFI. 
10. Приложение защинено от XPath или XML инъекций. 

### V6.1 Шифрование данных

**Средние и высокие требования:** 

1. Регулируемые законами персональные данные хранятся в зашифрованном виде \(например, личные данные, чувствительная личная информация или данные, являющиеся объектом регламента GDPR\) 
2. Регулируемые законами данные о здоровье хранятся в зашифрованном виде \(например, медицинские записи, данные с медицинских устройств или деанонимизированные записи исследований\). 
3. Регулируемые законом финансовые данные хранятся в зашифрованном виде \(например, данные аккаунтов, кредитная история, налоговые записи, история платежей, бенефициары или деанонимизированные записи маркетинговых и иных исследований\). 

### V6.2 Алгоритмы

**Низкие, средние и высокие требования:** 

1. Все криптографические модули отказывают безопасно и ошибки обрабатываются так, чтобы невозможно было организовать атаку Padding Oracle.

**Только средние и высокие требования:** 

1. Используются общие для индустрии или утвержденные правительством криптографические алгоритмы, режимы и библиотеки, самодельные алгоритмы не используются. 
2. Вектор инициализации шифрования, конфигурация шифра, режимы блока настроены безопасно. 
3. Алгоритмы генерации случайного числа, шифрования или хеширования, длины ключа, округления, шифра или режимов могут быть перенастроены, обновлены или заменены в любое время, чтобы защититься от дыр в криптографии. 
4. Не используются небезопасные режимы шифрования \(ECB и так далее\),  дополнения \(PKCS\#1 v1.5 и так далее\), шифры с малым размером блока \(Triple-DES, Blowfish и так далее\) и слабые алгоритмы хеширования \(MD5, SHA1 и так далее\) за исключением случаев, когда необходимо реализовать обратную совместимость. 
5. Одноразовые числа и векторы инициализации должны использоваться только один раз для данного криптографического ключа. Метод генерации ключа должен подходить для используемого алгоритма шифрования. 

**Только высокие требования:** 

1. Зашифрованные данные аутентифицируются через подписи, аутентифицированные режимы шифрования или через HMAC, чтобы удостовериться, что шифротекст не изменяется несанкционированной стороной. 
2. Все криптографические операции происходят за определенное время, нет "обходных путей" в операциях сравнения, вычисления, чтобы избежать утечек информации. 

### V6.3 Случайные значения

**Средние и высокие требования:** 

1. Все случайные числа, имена файлов, GUID'ы и случайные строки генерируются при помощи безопасных криптографических модулей, генератор случайных чисел не предугадается атакующим. 
2. Случайные GUID'ы созданы с использованием алгоритма GUID v4 и криптографически безопасного генератора псевдо-рандомных чисел \(CSPRNG\). GUID, созданный при помощи других генераторов псевдо-рандома, может быть предсказуемым. 

**Только высокие требования:** 

1. Случайные числа созданы при помощи достаточной энтропии даже когда приложение находится под высокой нагрузкой. 

### V6.4 Управление секретами

**Средние и высокие требования:** 

1. Используется решение для управления секретами, например, хранилище ключей используется для того, чтобы создавать, хранить, контролировать доступ и уничтожать секреты. 
2. Ключи генерируются не в приложении, а в изолированном безопасном модуле для криптографических операций. 

### V8.3 Конфиденциальные личные данные

**Низкие, средние и высокие требования:** 

1. Все конфиденциальные данные создаваемые и обрабатываемые приложением определены и используются политики обработки этих данных. 

**Только средние и высокие требования:** 

1. Доступ к конфиденциальным данным логируется \(при этом не логируются сами данные\) в случае, если данные собраны в соответствии с директивами защиты данных или когда логирование доступа необходимо. 
2. Конфиденциальная информация, хранимая в памяти, перезаписана нулями или случайными данными сразу после того, как в ее использовании отпала необходимость, чтобы смягчить последствия атак выгрузки памяти. 
3. Конфиденциальные данные, которые необходимо шифровать, зашифрованы с использованием алгоритмов, гарантирующих конфиденциальность и целостность. 
4. Конфиденциальные личные данные описаны в классификации хранения данных, например, старые или устаревшие данные удаляются автоматически, по расписанию или в зависимости от ситуации. 

### V9.1 Безопасность коммуникаций

**Низкие, средние и высокие требования:**

1. TLS используется для всех клиентских соединений и под нагрузкой не используется другой небезопасный протокол коммуникации. 
2. Используются онлайн или обновленные средства тестирования TLS, которые проверяют, что используются только надежные алгоритмы, шифры. 
3. Устаревшие версии SSL и TLS протоколов, алгоритмов, шифров и конфигураций отключены. Например, отключены SSLv2, SSLv3 или TLS 1.0 и 1.1. 

### V9.2 Безопасность серверных коммуникаций

**Средние и высокие требования:** 

1. Соединения от и к серверу используют доверенные TLS сертификаты. Когда используются самоподписанные сертификаты, сервер должен быть настроен доверять только специальным внутренним центрам сертификации. Остальные должны быть отклонены.  
2. Для всех входящих и исходящих соединений используется защищенный \(с использованием шифрования\) протокол коммуникации, такой как TLS, включая управление портами, мониторинг, аутентификацию, API, вызовы веб-сервисов, базы данных, облачные, бессерверные, мейнфрейм, внешние и партнерские соединения. Сервер под нагрузкой не должен переключаться на использование незашифрованных протоколов. 
3. Все зашифрованные соединения с внешними системами, при которых используется конфиденциальная информация или функции, аутентифицируются. 
4. Используется надежное средство отзыва сертификатов, например подключена и настроена система Online Certificate Status Protocol \(OCSP\) Stapling.

**Только высокие требования:** 

1. Ошибки соединений TLS логируются на бекенде. 

### V10.2 Поиск вредоносного кода

**Средние и высокие требования:**

1. Исходный код приложения и сторонних библиотек не содежрит функций неавторизованного сбора данных. Если такая функциональность существует, получите пользовательское разрешение на сбор данных, прежде чем его производить. 
2. Приложение не запрашивает чрезмерный доступ к разрешениям в части приватных функций или сенсоров, например, доступ к контактам, камерам, микрофонам или геолокации. 

**Только высокие требования:** 

1. Исходный код приложения и сторонние библиотеки не содержат бекдоров, как, например, жестко закодированных или дополнительных недокументированных  аккаунтов, ключей, обфускаций, недокументированных бинарных объектов, руткитов, анти-дебаг или небезопасный дебаг или иным образом устаревшую, небезопасную или скрытую функциональность, которую атакующий может использовать, если обнаружит. 
2. Исходный код приложения и сторонние библиотеки не содержат бомб замедленного действия, весь код просканирован на наличие функций, связанных с датой и временем. 
3. Исходный код приложения и сторонние библиотеки не содержат вредоносного кода, например, salami attacks, logic bypasses, logic bombs.
4. Исходный код приложения и сторонние библиотеки не содержат в себе пасхальных яиц или иной нежелаемой функциональности. 

### V12.2 Целостность файлов

**Средние и высокие требования:**

1. Контент файлов, полученных от недоверенных источников, проверяется на соответствие формату. 

### V12.3 Обработка файлов

**Низкие, средние и высокие требования:**

1. Отправленные пользователем метаданные файла не используются напрямую системой,  фреймворком или API URL, чтобы избежать уязвимости path traversal.
2. Имя файла, отправленного пользователем, валидируется или игнорируется, чтобы предотвратить раскрытие, создание, обновление или удаление локальных файлов \(LFI\).
3. Имя файла, отправленного пользователем, валидируется или игнорируется, чтобы предотвратить раскрытие или запуск удаленных файлов \(RFI\), что может также привести к SSRF атаке. 
4. Приложение защищено от атаки reflective file download \(RFD\), оно валидирует или игнорирует отправленные пользователем имена файлов в JSON, JSONP или URL параметрах, в ответах заголовки Content-Type должны содержать чистый текст, заголовки Content-Disposition должны иметь фиксированное имя файла. 
5. Метаданные недоверенных файлов не используются напрямую в API или библиотеках для предотвращения инъекций команд в ОС. 

**Только средние и высокие требования:** 

1. Приложение не включает в себя и не исполняет функционал из недоверенных источников, как, например, из неподтвержденных CDN, библиотек JavaScript, npm библиотек или серверных DLL. 

### V12.4 Хранение файлов

**Низкие, средние и высокие требования:**

1. Файлы, полученные из недоверенных источников, хранятся за пределами директории веб-приложения, ограничены в разрешениях со строгой валидацией. 
2. Файлы, полученные из недоверенных источников, сканируются антивирусом, чтобы предотвратить загрузку известного вредоносного кода. 

### V12.6 Защита от SSRF

**Низкие, средние и высокие требования:**

1. В приложении и на сервере используется белый список ресурсов и систем, к которым сервер может отправлять запросы или с которых он может загружать данные и файлы. 

### V13.4 GraphQL и прочие слои данных веб-сервисов

**Средние и высокие требования:**

1. Белый список запросов или комбинация лимитов на глубину и количество запросов используются для предотвращения DoS, как результата сложных, вложенных запросов. Для более продвинутых сценариев, следует использовать анализ стоимости запроса. 
2. Авторизация в GraphQL или ином другом слое данных производится на уровне бизнес-логики, вместо уровня GrapgQL. 

### V14.5 Валидация заголовков HTTP запросов

**Низкие, средние и высокие требования:**

1. Сервер приложения принимает только те методы HTTP, которые используются приложением или API, включая pre-flight OPTIONS. 
2. Полученный заголовок Origin не используется для аутентификации или в управлении доступом, так как этот заголовок может быть легко изменен атакующим. 
3. Заголовок cross-domain resource sharing \(CORS\) Access-Control-AllowOrigin использует строгий белый список доверенных доменов и не принимает параметр "null".

**Только средние и высокие требования:** 

1. Заголовки HTTP, добавленные доверенными прокси или через SSO, аутентифицируются приложением. 

### V5.1 Проверка ввода

**Низкие, средние и высокие требования:**

1. Приложение защищено от атак загрязнения HTTP параметров, особенно, если фреймворк приложения не различает источник параметров запроса \(GET, POST, куки, заголовки или переменные окружения. 
2. Фреймворк защищен от массового присвоения параметров или приложение имеет контр-меры, чтобы предотвратить небезопасное присвоение параметров. 
3. Весь ввод \(поля форм HTML, запросы REST, параметры URL, заголовки HTTP, куки, исполняемые файлы, RSS рассылки и прочее\) валидируются с использованием белого списка. 
4. Все структурированные данные строго типизированы и валидируются через описанную схему, содержащую разрешенные символы, длину и патерны \(номера кредитных карт или телефон или проверка на факт соответствия указанного города индексу\). 
5. URL перенаправляет только на ресурсы из белого списка или показывает предупреждение, когда перенаправление происходит на потенциально ненадежный контент. 

## Сборка и развертывание

### V10.1 Контроль целостности кода

**Высокие требования:** 

1. Используется средство анализа кода, выявляющее потенциально уязвимый код, как, например функции времени, небезопасные операции с файлами и сетевые соединения. 

### V10.3 Контроль целостности развернутого приложения

**Низкие, средние и высокие требования:**

1. Приложение имеет функцию автообновления клиента или сервера, обновления происходят через защищенный канал с использованием цифровой подписи. Код обновления должен подтверждать цифровую подпись прежде чем устанавливать или исполнять обновление. 
2. Приложение использует защиту целостности, как, например, подпись кода или целостность подресурса. Приложение не должно загружать или исполнять код из недоверенных источников, как, например, плагины, код, библиотеки. 
3. Приложение имеет защиту от угона поддоменов. Проверяются записи DNS или CNAME на предмет устарелости. Производится регулярная проверка доменных имен, используемых в приложении на предмет истечения срока действия или изменения. 

### V14.1 Сборка

**Средние и высокие требования:**

1. Процессы сборки и развертывания приложения производятся безопасно, например, произведена автоматизация CI /CD, автоматизированы конфигурации и существуют скрипты автоматического развертывания. 
2. Флаги компилятора настроены таким образом, чтобы обеспечить безопасную сборку \(включение всех доступных оповещений о переполнении буфера, рандомизация стека, предотвращение исполнения данных, остановка сборки если найдены небезопасные операции с указателями, памятью, форматированием строк\)
3. Конфигурация сервера настроена в соответствии с рекомендациями приложения сервера и используемых фреймворков. 
4. Приложение, конфигурации и все зависимости могут быть развернуты при помощи скриптов, составленных из документированных и протестированных последовательностей команд в разумные сроки или они могут быть восстановлены из резервных копий своевременно. 

**Только высокие требования:**

1. Авторизованные администраторы могут проверить целостность всех важных с точки зрения безопасности конфигураций для определения вмешательства в них. 

### V14.2 Зависимости

**Низкие, средние и высокие требования:**

1. Все компоненты обновлены. Во время сборки или компиляции используется dependency checker для проверки версий библиотек. 
2. Все неиспользуемые функции, документация, примеры и конфигурации удалены, например, тестовые приложения, документация платформы или пользователи по умолчанию и временные пользователи для тестов. 
3. Если элементы приложения, такие как библиотеки JavaScript, таблицы стилей CSS или шрифты хранятся во внешней сети доставки контента \(CDN\) или у внешнего провайдера, то используются средства проверки целостности ресурсов \(Subresource Integrity или SRI\). 

**Только средние и высокие требования:**

1. Все сторонние компоненты поставляются от определенных, доверенных и постоянно обновляемых репозиториев. 
2. Существует перечень всех используемых сторонних библиотек. 
3. Сторонние библиотеки работают из песочницы или через wrapper'ы, чтобы добиться только требуемого от них поведения в приложении для уменьшения поверхности атаки.

## Тестирование 

### V2.1 Безопасность паролей

**Низкие, средние и высокие требования:**

1. Пароли, установленные пользователем, не менее 12 символов в длину. 
2. Пароли длиннее 64 символов разрешены. 
3. Пароли могут содержать пробелы и они не обрезаются. 
4. Символы юникода разрешены в паролях. 
5. Пароли могут менять их пароль. 
6. Смена пароля требует ввода текущего и нового пароля. 
7. Введенные при регистрации, логин и пароль проверяются на предмет утечки локально \(например, используя топ-1000 или топ-10000 самых частых паролей\) или используя внешний API. Если используется внешний API, то используется доказательство с нулевым разглашением или другой механизм, чтобы удостовериться, что пароль не отправляется в чистом виде. Если пароль найден в утечках, то пользователю требуется поставить новый, безопасный пароль. 
8. Измерение сложности пароля отображается, чтобы помочь пользователю установить сложный пароль. 
9. Нет правил составления пароля, лимитирующих использование символов. Не должно быть требования об использовании заглавных или строчных букв, чисел или специальных символов. 
10. Нет требований к периодической ротации учетных данных или истории паролей. 
11. Функция "вставить", расширения менеджеров паролей для браузеров и внешние менеджеры паролей разрешены. 
12. Пользователь может временно показать замаскированный пароль или временно показать последние символы пароля. 

### V2.5 Восстановление учетных данных 

**Низкие, средние и высокие требования:**  

1. Сгенерированный системой начальный ключ активации или восстановления секрета не отправляется в виде чистого текста пользователю. 
2. Подсказки для паролей или "секретные вопросы" не используются. 
3. Процесс восстановления пароля не показывает текущий пароль. 
4. Общие аккаунты и стандартные \(например, "root", "admin" или "sa"\) не представлены в системе. 
5. Если способ аутентификации изменен или удален, пользователь уведомляется об этом. 
6. При восстановлении пароля или при иных действиях восстановления, используется безопасный механизм восстановления, например, TOTP или пуш-уведомления или другой механизм восстановления офлайн. 

**Только средние и высокие требования:** 

1. Если данные для мультифакторной аутентификации утеряны, то для восстановления требуется данных и действий не меньше, чем при регистрации. 

### \*\*\*V2.6 Look-up Secret Verifier Requirements

**Medium and high requirements:** 

1. Verify that lookup secrets can be used only once.
2. Verify that lookup secrets have sufficient randomness \(112 bits of entropy\), or if less than 112 bits of entropy, salted with a unique and random 32-bit salt and hashed with an approved one-way hash.
3. Verify that lookup secrets are resistant to offline attacks, such as predictable values.

### \*\*\*V2.7 Out of Band Verifier Requirements

**Low, medium and high requirements:** 

1. Verify that clear text out of band \(NIST "restricted"\) authenticators, such as SMS or PSTN, are not offered by default, and stronger alternatives such as push notifications are offered first.
2. Verify that the out of band verifier expires out of band authentication requests, codes, or tokens after 10 minutes. 
3. Verify that the out of band verifier authentication requests, codes, or tokens are only usable once, and only for the original authentication request.
4. Verify that the out of band authenticator and verifier communicates over a secure independent channel.

**Medium and high requirements only:** 

1. Verify that the out of band verifier retains only a hashed version of the authentication code.
2. Verify that the initial authentication code is generated by a secure random number generator, containing at least 20 bits of entropy \(typically a six digital random number is sufficient\).

### V2.8 Одноразовый код при одно- и мультифакторной верификации

**Низкие, средние и высокие требования:** 

1. Одноразовые пароли истекают за определенное время. 

**Только средние и высокие требования:** 

1. Используются симметричные ключи, чтобы отправленные ключи были хорошо защищены, например, используются аппаратные модули безопасности или хранилища ключей на основе безопасной ОС. 
2. Используются надежные криптографические алгоритмы при генерации и верификации. 
3. Одноразовый пароль может быть использовать только один раз в период его действия. 
4. Если одноразовый токен использован более одного раза, то это действие логируется и токен отвергается с отправкой уведомления безопасности владельцу устройства. 
5. Физический генератор одноразовых паролей может быть отозван в случае его кражи или потери. Все активные сессии, в которых используются ключи этого устройства, отзываются вне зависимости от локации. 
6. Биометрическая аутентификация используется только как дополнительное средство аутентификации вместе с использованием чего-нибудь, что пользователь имеет или с тем, что он знает. 

### V2.9 Криптографическое ПО и устройства верификации

**Средние и высокие требования:**

1. Криптографические ключи, используемые при верификации, хранятся в безопасности и защищены от раскрытия. Например, используется  TPM или HSM или сервис ОС, использующий секретное хранилище. 
2. Случайное число составляет не менее 64 битов в длину, статистически уникально или уникально на время использования криптографического устройства. 
3. Используются проверенные алгоритмы при генерации и верификации. 

### V2.10 Аутентификация сервисов

**Средние и высокие требования:** 

1. Секреты интеграций не зависят от несменяемых паролей \(API ключи, общие привилегированные аккаунты\)
2. Пароли хранятся в безопасном месте, чтобы предотвратить восстановление их офлайн перебором. 
3. Пароли, интеграции с базами данных и сторонними системами, внутренние секреты и ключи API хранятся безопасно и не включены в исходный код и не хранятся в репозиториях исходного кода. Хранилище секретов должно быть устойчиво к офлайн перебору

### V3.1 Фундаментальные принципы администрирования сеансов

**Требования низкого, среднего и высокого уровня:** 

1. Приложение никогда не отображает токены сессий в URL параметрах или в сообщениях об ошибках системы.

### V3.2 Требования к связи сеансов с соответствующими пользователями

**Требования низкого, среднего и высокого уровней:** 

1. Приложение генерирует новый сессионный токен при аутентификации пользователя. 
2. Токены включают не менее 64-х бит энтропии.
3. Приложение хранит токены только в браузере используя безопасные методики, такие как защищённые куки, или хранение данных сеанса в HTML 5.

 **Требования только среднего и высокого уровней:** 

1. Токены сеанса генерируются применяя только проверенные криптографические алгоритмы.

### V3.3 Завершение сессии и ее таймаут

**Требования низкого, среднего и высокого уровней:** 

1. Выход из учётной записи, а также истечения срока аутентификации нейтрализуют токены сеанса, к примеру чтобы кнопки навигации или системы зависящие от входящих потоков не возобновляли аутентифицированный сеанс, включая системы последующих уровней зависимости. 
2. При позволении верификатором оставаться пользователям в учётной записи, повторные аутентификации проходят периодически вне зависимости от степени активности пользователя.

**Требования только среднего и высокого уровней:**

1. Приложение приостанавливает все активные сессии при смене пароля кроме той, откуда происходит успешная смена пароля. Процедура работает на всех уровнях и ветвях приложения.
2. Пользователь имеет возможность выйти из учётных записей, приостановляя тем самым активные сессии на разных или всех устройствах.

### V3.4 Управление куки-сессиями

**Требования низкого, среднего и высокого уровней:** 

1. токены куки имеют 
   1. Атрибут 'Secure'. 
   2. Атрибут 'HttpOnly'. 
   3. Атрибут 'SameSite' для предотвращения CSRF атак \(в отличие от скриптовых аттак, они вынуждают пользователя произвести вредоносный запрос\).
2. Токены куки используют "\_\_Host-" префикс для предоставления своей конфиденциальности.
3. Если приложение опубликовано на домене с другими приложениями, позволяющими модифицировать куки каким-либо способом,  атрибут пути сообщается самым точным возможным способом.

### V3.5 Управление токен-сессиями

**Требования только среднего и высокого уровней:** 

1. Verify the application does not treat OAuth and refresh tokens — on their own — as the presence of the subscriber and allows users to terminate trust relationships with linked applications.
2. Приложение использует токены сеансов вместо статичных API, секретов и ключей, если это не легаси-приложение.
3. Verify that stateless session tokens use digital signatures, encryption, and other countermeasures to protect against tampering, enveloping, replay, null cipher, and key substitution attacks.

### V3.6 Re-authentication from a Federation or Assertion

**High requirements only:**

1. Зависимые стороны указывают в CSP максимальное время для прохождения аутентификации, а CSP требует повторной аутентификации, если сторона не использовали выданную сессию за указанное время. 
2. CSP информирует стороны о последних событиях аутентификации, чтобы дать возможность RP понять, есть ли необходимость в повторной аутентификации клиента. 

### V3.7 Defenses Against Session Management Exploits

**Low, medium and high requirements:** 

1. Приложение проверяет, что используется валидная сессия или требует повторной аутентификации или верификации через второй фактор, прежде чем позволить пользователю производить конфиденциальные транзакции или вносить изменения в аккаунт. 

### V5.4 Memory, String, and Unmanaged Code Requirements

**Medium and high requirements:**

1. Verify that the application uses memory-safe string, safer memory copy and pointer arithmetic to detect or prevent stack, buffer, or heap overflows.
2. Verify that format strings do not take potentially hostile input, and are constant.
3. Verify that sign, range, and input validation techniques are used to prevent integer overflows.

### V5.5 Deserialization Prevention Requirements

**Low, medium and high requirements:**

1. Verify that serialized objects use integrity checks or are encrypted to prevent hostile object creation or data tampering.
2. Verify that the application correctly restricts XML parsers to only use the most restrictive configuration possible and to ensure that unsafe features such as resolving external entities are disabled to prevent XXE.
3. Verify that deserialization of untrusted data is avoided or is protected in both custom code and third-party libraries \(such as JSON, XML and YAML parsers\).
4. Verify that when parsing JSON in browsers or JavaScript-based backends, JSON.parse is used to parse the JSON document. Do not use eval\(\) to parse JSON.

### V8.2 Client-side Data Protection

**Low, medium and high requirements:**

1. Verify the application sets sufficient anti-caching headers so that sensitive data is not cached in modern browsers.
2. Verify that data stored in client side storage \(such as HTML5 local storage, session storage, IndexedDB, regular cookies or Flash cookies\) does not contain sensitive data or PII.
3. Verify that authenticated data is cleared from client storage, such as the browser DOM, after the client or session is terminated.

### 

### \*V11.1 Безопасность бизнес-логики

**Низкие, средние и высокие требования:**

1. Приложение исполняет шаги бизнес логики для пользователя последовательно и без пропуска шагов. 
2. Приложение исполняет каждый шаг бизнес логики в реалистичное время для человека, другими словами, транзакции не проводятся слишком быстро. 
3. Приложение имеет лимиты для отдельных бизнес процессов или транзакций, которые выполняются для каждого пользователя отдельно. 
4. В приложении реализованы лимиты для обнаружения и защиты от автоматизированных атак по типу фильтрации данных, чрезмерного обращения к процессам бизнес логики, чрезмерной загрузки файлов или DOS \(отказ в обслуживании\)
5. * Приложение имеет лимиты для бизнес логики или валидации для защиты от возможных бизнес-рисков или угроз, выявленных с помощью моделирования угроз или похожих методик. 

**Только средние и высокие требования:**

1. Приложение не испытывает проблем с "time of check to time of use" \(TOCTOU\) и других проблем с важными процессами в состоянии гонки. 
2. Приложение отслеживает необычные события или активность с точки зрения бизнес-логики. Например, попытки совершить действия не по порядку или действия, которые обычный пользователь никогда бы не предпринял. 
3. Приложение имеет настраиваемую систему оповещения об обнаружении автоматизированных атаках или необычной активности. 

### V12.1 File Upload Requirements

**Low, medium and high requirements:**

1. Verify that the application will not accept large files that could fill up storage or cause a denial of service attack.

**Medium and high requirements only:**

1. Verify that compressed files are checked for "zip bombs" - small input files that will decompress into huge files thus exhausting file storage limits.
2. Verify that a file size quota and maximum number of files per user is enforced to ensure that a single user cannot fill up the storage with too many files, or excessively large files.

### V12.5 File Download Requirements

**Low, medium and high requirements:**

1. Verify that the web tier is configured to serve only files with specific file extensions to prevent unintentional information and source code leakage. For example, backup files \(e.g. .bak\), temporary working files \(e.g. .swp\), compressed files \(.zip, .tar.gz, etc\) and other extensions commonly used by editors should be blocked unless required.
2. Verify that direct requests to uploaded files will never be executed as HTML/JavaScript content.

### V13.1 Generic Web Service Security Verification Requirements

**Low, medium and high requirements:**

1. Verify that all application components use the same encodings and parsers to avoid parsing attacks that exploit different URI or file parsing behavior that could be used in SSRF and RFI attacks.
2. Verify that access to administration and management functions is limited to authorized administrators.
3. Verify API URLs do not expose sensitive information, such as the API key, session tokens etc.

**Medium and high requirements only:**

1. Verify that authorization decisions are made at both the URI, enforced by programmatic or declarative security at the controller or router, and at the resource level, enforced by model-based permissions.
2. Verify that requests containing unexpected or missing content types are rejected with appropriate headers \(HTTP response status 406 Unacceptable or 415 Unsupported Media Type\).

### V13.2 RESTful Web Service Verification Requirements

**Low, medium and high requirements:**

1. Verify that enabled RESTful HTTP methods are a valid choice for the user or action, such as preventing normal users using DELETE or PUT on protected API or resources.
2. Verify that JSON schema validation is in place and verified before accepting input.
3. Verify that RESTful web services that utilize cookies are protected from CrossSite Request Forgery via the use of at least one or more of the following: triple or double submit cookie pattern \(see references\), CSRF nonces, or ORIGIN request header checks.

**Medium and high requirements only:**

1. Verify that REST services have anti-automation controls to protect against excessive calls, especially if the API is unauthenticated.
2. Verify that REST services explicitly check the incoming Content-Type to be the expected one, such as application/xml or application/JSON.
3. Verify that the message headers and payload are trustworthy and not modified in transit. Requiring strong encryption for transport \(TLS only\) may be sufficient in many cases as it provides both confidentiality and integrity protection. Permessage digital signatures can provide additional assurance on top of the transport protections for high-security applications but bring with them additional complexity and risks to weigh against the benefits.

### 

### V14.3 Непреднамеренное раскрытие информации

**Низкие, средние и высокие требования:**

1. Сообщения об ошибках фреймворка, веб и серверных приложений настроены и доставляют пользователю актуальные, персонализированные ответы для избежания непреднамеренного раскрытия конфиденциальной и иной критичной с точки зрения безопасности системной информации.   
2. Отладочные режимы фреймворка, веб и серверных приложений отключены в рабочем окружении, чтобы опции отладки, консоли разработчика были отключены во избежание непреднамеренного раскрытия конфиденциальной и иной критичной с точки зрения безопасности системной информации.   
3. Заголовки или иные части HTTP ответа не раскрывают детальную информацию о компонентах системы и информацию о версиях.  

### V14.4 HTTP Security Headers Requirements

**Low, medium and high requirements:**

1. Verify that every HTTP response contains a content type header specifying a safe character set \(e.g., UTF-8, ISO 8859-1\).
2. Verify that all API responses contain Content-Disposition: attachment; filename="api.json" \(or other appropriate filename for the content type\).
3. Verify that a content security policy \(CSPv2\) is in place that helps mitigate impact for XSS attacks like HTML, DOM, JSON, and JavaScript injection vulnerabilities.
4. Verify that all responses contain X-Content-Type-Options: nosniff.
5. Verify that HTTP Strict Transport Security headers are included on all responses and for all subdomains, such as Strict-Transport-Security: max-age=15724800; includeSubdomains.
6. Verify that a suitable "Referrer-Policy" header is included, such as "no-referrer" or "same-origin".
7. Verify that a suitable X-Frame-Options or Content-Security-Policy: frameancestors header is in use for sites where content should not be embedded in a third-party site.

## Operations

### V7.1 Log Content Requirements

**Low, medium and high requirements:**

1. Verify that the application does not log credentials or payment details. Session tokens should only be stored in logs in an irreversible, hashed form.
2. Verify that the application does not log other sensitive data as defined under local privacy laws or relevant security policy.

**Medium and high requirements only:**

1. Verify that the application logs security relevant events including successful and failed authentication events, access control failures, deserialization failures and input validation failures.
2. Verify that each log event includes necessary information that would allow for a detailed investigation of the timeline when an event happens. 

### V7.2 Log Processing Requirements

**Medium and high requirements:**

1. Verify that all authentication decisions are logged, without storing sensitive session identifiers or passwords. This should include requests with relevant metadata needed for security investigations.
2. Verify that all access control decisions can be logged and all failed decisions are logged. This should include requests with relevant metadata needed for security investigations.

### V7.3 Log Protection Requirements

**Medium and high requirements:**

1. Verify that the application appropriately encodes user-supplied data to prevent log injection.
2. Verify that all events are protected from injection when viewed in log viewing software.
3. Verify that security logs are protected from unauthorized access and modification.
4. Verify that time sources are synchronized to the correct time and time zone. Strongly consider logging only in UTC if systems are global to assist with postincident forensic analysis.

### V7.4 Error Handling

**Low, medium and high requirements:**

1. Verify that a generic message is shown when an unexpected or security sensitive error occurs, potentially with a unique ID which support personnel can use to investigate.

**Medium and high requirements only:**

1. Verify that exception handling \(or a functional equivalent\) is used across the codebase to account for expected and unexpected error conditions.
2. Verify that a "last resort" error handler is defined which will catch all unhandled exceptions.

### V8.1 General Data Protection

**Medium and high requirements:**

1. Verify the application protects sensitive data from being cached in server components such as load balancers and application caches.
2. Verify that all cached or temporary copies of sensitive data stored on the server are protected from unauthorized access or purged/invalidated after the authorized user accesses the sensitive data.
3. Verify the application minimizes the number of parameters in a request, such as hidden fields, Ajax variables, cookies and header values.
4. Verify the application can detect and alert on abnormal numbers of requests, such as by IP, user, total per hour or day, or whatever makes sense for the application.

**High requirements only:**

1. Verify that regular backups of important data are performed and that test restoration of data is performed.
2. Verify that backups are stored securely to prevent data from being stolen or corrupted.

### 



